// Relic Phase 4: Functional-Relational Programming Examples
// This file demonstrates how relation declarations generate value types

// Define relation schemas - these generate multiple value types
relation Users {
    id: Int,
    name: String,
    email: String,
    age: Int,
    city: String
    
    key: id
    unique: email
}

// This declaration automatically generates:
// 1. value User(id: Int, name: String, email: String, age: Int, city: String)
// 2. value UsersRelation(rows: InternalStorage<User>)
// 3. Field constants: User.id, User.name, User.email, User.age, User.city
// 4. Constructor: fn Users(rows: List<User>) -> UsersRelation

relation Orders {
    id: Int,
    userId: Int,
    product: String,
    amount: Float,
    date: String
    
    key: id
    foreign: userId references Users.id
}

// Generates: Order value type, OrdersRelation type, Order.* fields

// In the new approach, query operations would be implemented as regular functions
// that operate on relation values. Here's how it would look:

// Example query functions (would be built into the standard library):
// fn where(rel: Relation, predicate: Expression) -> Relation { ... }
// fn select(rel: Relation, fields: List) -> Relation { ... }
// fn join(left: Relation, right: Relation, condition: Expression) -> Relation { ... }
// fn group(rel: Relation, by: List) -> GroupedRelation { ... }
// fn aggregate(grouped: GroupedRelation, ops: List) -> Relation { ... }

// Query examples using the functional approach:

// 1. Simple where clause - just a function call with UFC
// let adults = users.where(age >= 18) in adults

// 2. Select specific fields - would need list syntax or varargs
// let names = users.select([name, email]) in names

// 3. Chained query operations - natural with UFC
// let nyAdults = users
//     .where(city == "New York")
//     .where(age >= 21)
//     .select([name, email])
// in nyAdults

// 4. Join operations - multiple dispatch could optimize based on relation types
// let userOrders = users
//     .join(orders, users.id == orders.userId)
//     .select([users.name, orders.product, orders.amount])
// in userOrders

// 5. Aggregations - composable functions
// let orderTotals = orders
//     .group([userId])
//     .aggregate([sum(amount), count()])
// in orderTotals

// 6. Temporal queries - just another function
// let historicalUsers = users
//     .asOf("2024-01-01")
//     .where(status == "active")
// in historicalUsers

// Benefits of this approach:
// - No special parser support needed
// - Users can define custom query operations
// - Multiple dispatch enables optimization based on relation types
// - Queries are just function compositions
// - Relations are first-class values that can be passed around

// Note: Implementation of these query functions is future work.
// This demonstrates how the syntax would look without special parser support.
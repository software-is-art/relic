// Relic Phase 4: Functional-Relational Programming Examples
// This file demonstrates how relation declarations generate value types

// Define relation schemas - these generate multiple value types
relation Users {
    id: Int,
    name: String,
    email: String,
    age: Int,
    city: String
    
    key: id
    unique: email
}

// This declaration automatically generates:
// 1. value User(id: Int, name: String, email: String, age: Int, city: String)
// 2. value UsersRelation(rows: InternalStorage<User>)
// 3. Field constants: User.id, User.name, User.email, User.age, User.city
// 4. Constructor: fn Users(rows: List<User>) -> UsersRelation

relation Orders {
    id: Int,
    userId: Int,
    product: String,
    amount: Float,
    date: String
    
    key: id
    foreign: userId references Users.id
}

// Generates: Order value type, OrdersRelation type, Order.* fields

// Working with relation values:

// 1. Creating relation instances
// let users: UsersRelation = Users([
//     User(id: 1, name: "Alice", email: "alice@example.com", age: 30, city: "NYC"),
//     User(id: 2, name: "Bob", email: "bob@example.com", age: 25, city: "LA")
// ])

// 2. Type-safe queries with field references
// let adults: UsersRelation = users.where(u => u.age >= 18)
// let nyUsers: UsersRelation = users.where(u => u.city == "NYC")

// 3. Field references are type-safe constants
// let names = users.select(User.name, User.email)
// // Compiler knows this returns a relation with {name: String, email: String}

// 4. Working with individual rows
// match users.find(u => u.id == 1) {
//     Some(user: User) => println(user.name),  // "Alice"
//     None => println("Not found")
// }

// 5. Type-safe joins
// let userOrders = users.join(orders, (u, o) => u.id == o.userId)
// // Result has type JoinedRelation<User, Order>

// 6. Aggregations return values, not relations
// let userCount: Int = users.count()
// let avgAge: Float = users.avg(User.age)
// let oldestUser: Option<User> = users.maxBy(User.age)

// 7. Set operations preserve types
// let allUsers: UsersRelation = activeUsers.union(inactiveUsers)
// let commonUsers: UsersRelation = list1.intersect(list2)

// 8. Custom query functions with proper types
// fn findAdults(users: UsersRelation) -> UsersRelation {
//     users.where(u => u.age >= 18)
// }
//
// fn topUsersByCity(users: UsersRelation, city: String, n: Int) -> UsersRelation {
//     users
//         .where(u => u.city == city)
//         .sort(User.age.desc())
//         .limit(n)
// }

// Benefits of the value-generating approach:
// - Each row is a validated value object (parse don't validate)
// - Relations are immutable values that can be transformed
// - Type safety throughout - no string-based field names
// - Natural integration with pattern matching and UFC
// - Multiple dispatch enables storage strategy optimization
// - Users can extend with custom query operations

// Implementation notes:
// - Relation declarations generate all necessary types at compile time
// - Storage is copy-on-write for efficiency with immutability
// - Field constants enable refactoring and IDE support
// - Row values can be used independently of relations
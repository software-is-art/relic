# Pattern Matching and Row Typing for Relationships

This document explores potential syntax enhancements to make relationship queries more ergonomic in Relic.

## Current State vs. Future Possibilities

### Current Approach (Verbose but Explicit)
```relic
// Finding friends requires explicit conditionals
fn friendsOf(person: Person) -> List[Person] {
    Friendship.where(f => f.person1 == person.id || f.person2 == person.id)
        .map(f => f.person1 == person.id ? f.person2 : f.person1)
        .map(id => Person.find(p => p.id == id))
}
```

### Pattern Matching Approach
```relic
// Pattern match on tuple structure
fn friendsOf(person: Person) -> List[Person] {
    Friendship.collect {
        case Friendship(^person.id, otherId) => Person.get(otherId)
        case Friendship(otherId, ^person.id) => Person.get(otherId)
    }
}

// Or with guards
fn friendsOf(person: Person) -> List[Person] {
    Friendship.all().collectMatch {
        case f @ Friendship(p1, p2) if p1 == person.id => Person.get(p2)
        case f @ Friendship(p1, p2) if p2 == person.id => Person.get(p1)
    }
}
```

### Row Typing / Structural Access
```relic
// Destructure in where clauses
fn friendsOf(person: Person) -> List[Person] {
    Friendship
        .where { {person1, person2} => 
            person1 == person.id || person2 == person.id 
        }
        .map { {person1, person2} =>
            if person1 == person.id then Person.get(person2)
            else Person.get(person1)
        }
}

// Or with row polymorphism
fn involves[R: {person1: Int, person2: Int, ...}](
    relation: R, 
    personId: Int
) -> Bool {
    relation.person1 == personId || relation.person2 == personId
}
```

## Symmetric Relationship Patterns

### Explicit Symmetric Declaration
```relic
// Declare symmetry at type definition
value Friendship(person1: PersonId, person2: PersonId) symmetric {
    validate: person1 != person2
}

// Compiler generates helper methods
impl Friendship {
    // Auto-generated by 'symmetric' keyword
    fn involves(self, id: PersonId) -> Bool
    fn other(self, id: PersonId) -> PersonId
    fn people(self) -> (PersonId, PersonId)
}

// Clean queries
let friends = Friendship.involving(person.id)
    .map(f => f.other(person.id))
    .map(Person.get)
```

### Pattern Matching with Symmetric
```relic
// Special pattern syntax for symmetric relationships
fn friendsOf(person: Person) -> List[Person] {
    Friendship.match {
        // ~ means "either position"
        case (~person.id, other) => Person.get(other)
    }
}
```

## Advanced Pattern Matching

### Multi-way Relationships
```relic
value Meeting(organizer: PersonId, participants: List[PersonId], time: DateTime) {
    validate: !participants.contains(organizer)
    validate: participants.length > 0
}

// Pattern match on complex structures
fn meetingsWith(person: Person) -> List[Meeting] {
    Meeting.match {
        case Meeting(^person.id, _, _) => true  // As organizer
        case Meeting(_, participants, _) if participants.contains(person.id) => true
        case _ => false
    }
}
```

### Nested Pattern Matching
```relic
// Match on relationship attributes
fn strongFriendships(person: Person) -> List[Person] {
    Friendship.collect {
        case Friendship(^person.id, friend, strength) if strength > 7 => 
            Person.get(friend)
        case Friendship(friend, ^person.id, strength) if strength > 7 => 
            Person.get(friend)
    }
}
```

## Row Typing Benefits

### Generic Relationship Functions
```relic
// Works with any relationship that has person1/person2 fields
fn symmetricQuery[R: {person1: PersonId, person2: PersonId, ...}](
    relationName: Type[R],
    personId: PersonId
) -> List[PersonId] {
    all(relationName)
        .filter(r => r.person1 == personId || r.person2 == personId)
        .map(r => if r.person1 == personId then r.person2 else r.person1)
}

// Use with any symmetric relationship type
let friends = symmetricQuery(Friendship, alice.id)
let collaborators = symmetricQuery(Collaboration, alice.id)
```

### Relationship Combinators
```relic
// Generic "involves" for any binary relationship
fn involves[R: {person1: PersonId, person2: PersonId, ...}](
    r: R, 
    id: PersonId
) -> Bool {
    r.person1 == id || r.person2 == id
}

// Generic "between" for any binary relationship  
fn between[R: {person1: PersonId, person2: PersonId, ...}](
    r: R,
    id1: PersonId, 
    id2: PersonId
) -> Bool {
    (r.person1 == id1 && r.person2 == id2) ||
    (r.person1 == id2 && r.person2 == id1)
}
```

## Implementation Considerations

### Compiler Support Needed

1. **Pattern Matching**
   - Extend pattern syntax to support value type destructuring
   - Add pin operator (^) for matching against variables
   - Support guards in pattern cases

2. **Row Typing**
   - Structural typing for record access
   - Row polymorphism for generic functions
   - Type inference for anonymous row types

3. **Symmetric Keyword**
   - Generate standard methods for symmetric relationships
   - Ensure normalization is applied correctly
   - Optimize queries on symmetric relationships

### Performance Implications

The compiler can optimize these patterns:
- Pattern matching compiles to efficient switch statements
- Row typing enables monomorphization 
- Symmetric relationships can use specialized indices

## Migration Path

### Phase 1: Manual Helpers
```relic
// Start with explicit helper functions
impl Friendship {
    fn involves(self, id: PersonId) -> Bool {
        self.person1 == id || self.person2 == id
    }
}
```

### Phase 2: Pattern Matching
```relic
// Add pattern matching support
Friendship.collect {
    case Friendship(^targetId, other) => other
    case Friendship(other, ^targetId) => other  
}
```

### Phase 3: Full Row Typing
```relic
// Generic relationship operations
fn relationshipGraph[R: Symmetric](type: Type[R]) -> Graph {
    // Build graph from any symmetric relationship type
}
```

## Conclusion

These syntax enhancements would make relationship queries significantly more ergonomic while maintaining Relic's core philosophy. The key is that these are purely syntactic improvements - the underlying model of "relationships as values" remains unchanged. The compiler can transform the enhanced syntax into the same efficient operations, providing both elegance and performance.